---
layout: post
title: 近期DP题目
date: 2025-05-26
tags:
- ACM-ICPC
categories: ACM-ICPC
description: 描述
---

## 几道DP题目
牛客练习赛139C，25武汉邀请赛FG等
<!-- more -->

[C-大卫的密码_牛客练习赛139](https://ac.nowcoder.com/acm/contest/110698/C)

**题意：** 

给定一个  $n\times m$  的网格图，我们使用 $(i,j)$ 表示网格中从上往下数第 $i$ 行和从左往右数第 $j$ 列的单元格。左上角为 $(1,1)$ ，右下角为  $(n,m)$ ，每个格子包含一个整数价值，使用 $a_{i,j}$ 表示。
一个光标在上面移动，从 $(s,1)$ 出发，每次可以向右或者向下移动，每个格子至多经过一次。当光标移动到  $(n,i) \left(1\le i\le m \right)$ 格子，也就是最后一行的某个格子时，继续向下移动则会到达 $(1,i)$ 格子。大卫需要移动光标到达 $(t,m)$ ，求最终大卫能获取的最大价值和。

**题解：**

二维DP+限制。定义状态 $dp[i][j]$ 表示在 $(i,j)$ 位置时的最大价值和。

因为纵向是可以走到底然后从上面走下来的，所以我们考虑转移的时候从左往右一列一列的转移。

设 $s_n=\sum_{i=1}^n a[i][j]$，则转移方程为
$$

dp_{i,j} \leftarrow \max_{k} \left( dp_{k,j-1} + 
\begin{cases} 
s_i - s_{k-1} & \text{if } ~k < i \\ 
s_n - (s_{k-1} - s_i) & \text{if } ~k > i 
\end{cases}
\right)
$$
因为这里面只有 $s_{k-1}$ 是不固定的，我们找到最小的 $k$ 进行转移就行了，DP数组可以滚动。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e3+10,M=1e6+10,inf=1e18+10;
ll Tt=1,n,m,s,t;
ll dp[2][N],a[N][N],l[N],r[N],sum[N];
void solve(){
	cin>>n>>m>>s>>t;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j];
	for(int i=1;i<=n;i++) dp[0][i]=-inf;
	dp[0][s]=0;
	for(int j=1;j<=m;j++){
		int now=j&1,pre=(j-1)&1;
		for(int i=0;i<=n+1;i++){
			l[i]=r[i]=-inf,sum[i]=0;
			dp[now][i]=dp[pre][i],dp[now][i]=0;
		}
		for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i][j];
		for(int i=1;i<=n;i++) l[i]=max(l[i-1],dp[pre][i]-sum[i-1]);
		for(int i=n;i>=1;i--) r[i]=max(r[i+1],dp[pre][i]+sum[n]-sum[i-1]);
		for(int i=1;i<=n;i++) dp[now][i]=max(l[i],r[i+1])+sum[i];
	}                                                         
	cout<<dp[m&1][t]<<"\n";
}
int main(){
	while(Tt--) solve();
	return 0;
}
```

[P12593 沉石鱼惊旋 - 洛谷](https://www.luogu.com.cn/problem/P12593)

**题意：**

有一张 $n$ 个点 $m$ 条边的简单无向带权连通图 $G$。可以进行 $n$ 次操作，每次操作如下：

选择一个仍未被删除的点 $u$，然后删除点 $u$ 和当前与 $u$ 相连的所有边（即其中一个端点是 $u$ 的边）。假设本次删除的边的边权分别是 $w_1, w_2,\dots w_k$，则本次操作的代价是  $k\times (w_1+w_2+\dots+w_k)$。

你的总代价是这 $n$ 次操作的代价和。将图中所有点和边都删除（即把图删空）的最小总代价是多少。

**题解：**

[题解](https://www.luogu.com.cn/problem/solution/P12593)

状压DP。定义状态为 $f[s]$ 为已经删过点的集合为 $s$ 时所能取得的最小代价，那么容易得出状态转移方程

$
f_S = \min_{\substack{1 \leq j \leq n \& j \notin S}} \left\{ f_{S \cup j} + \sum_{l \notin S} [(l,j)\in E] \sum_{l \notin S \& (l,j) \in E}{w_{l,j}} \right\}$

边界条件是当 $S={1,2,...,n}$ 时，$f_S=0$ ，因为删完了就不需要再付出代价了。答案即为 $f_\empty$，因为最开始的时候一个点也没删。

时间复杂度为 $O(2^nn^2)$，可以通过 $n ≤ 16$ 的范围。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll N = 10, M=30, INF=1e14;
ll n, m, g[N][N], dp[1<<N];
bool vis[1<<N];
ll f(ll i) {
	if(vis[i])return dp[i];
	if(i==(1<<n)-1) return 0;
	ll ans = INF;
	for(int j = 1; j <= n; j++) {
		if(!(i&(1<<(j-1)))) {
			ll k=0, v=0;
			for(int l = 1; l <= n; l++) {
				if(!(i&(1<<(l-1))) && g[j][l]>0) k++, v+=g[j][l];
			}
			ans=min(ans, f(i|(1<<(j-1)))+k*v);
		}
	}
	vis[i]=true, dp[i]=ans;
	return ans;
}
int main() {
	cin>>n>>m;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			g[i][j]=0;
	for(int i = 1; i <= m; i++) {
		int u, v, w; cin>>u>>v>>w;
		g[u][v]=w, g[v][u]=w;
	}
	cout<<f(0);	
	return 0;
}
```

[P12597 穿睡衣军训 - 洛谷](https://www.luogu.com.cn/problem/P12597)

**题意：**

给定两个字符串 $s,t$，扶苏想让你求出一个字符串 $x$，满足：

- $x$ 是 $s$ 的**子串**。
- $x$ 是 $t$ 的**子序列**。
- 在所有满足前述两条的字符串中，$x$ 的长度最长。
- 在所有满足前述三条的字符串中，$x$ 的字典序最小。

请你帮她求出这样的字符串 $x$。

**题解：**



```c++

```

[2025武汉邀请赛-F 背包](https://codeforces.com/gym/105901/problem/F)

**题意：**

有 $n$ 组物品 ，第 $i$ 组物品有 $a_i$ 个，每个物品的重量为 $2^{b^i}$。

有 $m$ 个背包，每个背包的承重为 $k$。求最小的 $k$，使得所有 $\sum_{i=1}^n a_i$ 个物品都能被放入背包中，每个背包物品总重量不超过 $k$。同一组不同物品可放不同背包。

**题解：**



```c++

```

[2025武汉邀请赛-G 路径求和问题](https://codeforces.com/gym/105901/problem/G)

**题意：**

有一个 $n\times m$ 的网格，每个格子写一个整数，第 $i$ 行第 $j$ 列的格子里写着整数 $a_{i,j}$。

从 $(1,1)$ 走到 $(n,m)$ ，只能往下走或者往右走。

一条路径的价值定义为路径上不同整数的数量。对于所有可能路径，求价值之和。

**题解：**



```c++

```



