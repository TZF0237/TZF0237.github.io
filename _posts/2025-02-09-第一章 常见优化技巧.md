---
layout: post
title: 第一章 常见优化技巧
date: 2025-02-09
tags:
- ACM-ICPC
- algorithm
categories: ACM-ICPC
---

常见优化技巧包含4个部分，双指针法，空间换时间，单调栈，单调队列。
<!-- more -->

## 双指针法

双指针又叫尺取法或者`two-pointers`，用两个指针维护一段序列区间的方法。

例1：[P1102 A-B 数对 ](https://www.luogu.com.cn/problem/P1102)

```c++
#include<bits/stdc++.h>
using namespace std;
int s[200010],n,c,l=1,r=1;
int main(){
	long long sum=0;
	cin>>n>>c;
	for(int i=1;i<=n;i++) cin>>s[i];
	sort(s+1,s+n+1);
	for(int i=1;i<=n;i++){
		while(s[l]<s[i]-c&&l<=n) l++;
		while(s[r]<=s[i]-c&&r<=n) r++;
		sum+=r-l;
	}
	cout<<sum;
	return 0;
}
```

例2：[P1638 逛画展](https://www.luogu.com.cn/problem/P1638)

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b,arr[1000010],num,ans=1e9,l=1,r=1;
map<int,int> mp;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>arr[i];
	while(l<=r&&r<=n+1){
		if(num<m){
			r++;
			mp[arr[r-1]]++;
			if(mp[arr[r-1]]==1) num++;
		}else{
			if(ans>r-l){
				ans=r-l,a=l,b=r-1;
			}
			mp[arr[l]]--;
			if(mp[arr[l]]==0) num--;
			l++;
		}
	}
	cout<<a<<" "<<b;
	return 0;
}
```

- 双指针法本质上是使用队列维护一个符合条件的区间。右指针增加相当于入队，左指针增加相当于出队。

例3：[P1115 最大子段和 ](https://www.luogu.com.cn/problem/P1115)

以第i个元素为右端点的全部区间中，可以取到最大区间和。在处理第i个元素时，判断要不要把以第i-1元素为右端点对应的区间最大值加上去。如果加上后还不如直接取第i个值，就不加上。即$f_i=max(f_{i-1}+a_i,a_i)$。由于每一个$f_i$都有可能是答案，所以还需要维护$f_i$的最大值作为答案。

```c++
#include<bits/stdc++.h>
using namespace std;
long long n,x,ans=-100000000,sum;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		sum=max(sum+x,x);
		ans=max(sum,ans);
	}
	cout<<ans;
	return 0;
}
```

## 空间换时间

例1：[P7072 直播获奖](https://www.luogu.com.cn/problem/P7072)

- 运用桶排序的思想，空间换取时间

```c++
#include<bits/stdc++.h>
using namespace std;
int t[610],n,w,tmp;
int main(){
	cin>>n>>w;
	for(int i=1;i<=n;i++){
		cin>>tmp;
		t[tmp]++;//加入对应分数的桶
		int sum=0;//累加人数
		for(int j=600;j>=0;j--){
			sum+=t[j];
			if(sum>=max(1,i*w/100)){
				cout<<j<<" ";
				break;
			}
		}
	}
	return 0;
}
```

例2：[P2671 求和 ](https://www.luogu.com.cn/problem/P2671)

- 如果要求$x<y<z,y-x=z-y$，只是限制$x,z$的奇偶性相同。
- 将题目中计算分数的式子拆开，得到$(x+z)*(a_x+a_z)=xa_x+xa_z+za_x+za_z$，通过枚举我们可以归纳为：对于所有系数为$i$的项，有$n-1$个 $ia_i$ 和 $i((\sum_{j=1}^na_j)-a_i)$ 。
- 使用 $s1$ 数组记录某种颜色且编号同一奇偶的格子数目，用 $s2$ 数组记录某种颜色且编号同一奇偶的格子数字总和。那么对于每一个 $i$ ，对答案的贡献就是 $i*((s2[y][i%2]-a[i])+a[i]*(s1[y][i%2]-1))==i*(s2[y][i%2]+a[i]*(s1[y][i%2]-2))$

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10,mod=10007;
int n,m,ans,a[maxn],b[maxn],s1[maxn][2],s2[maxn][2];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		cin>>b[i];
		s1[b[i]][i%2]++;//记录颜色为b[i]，且编号i奇偶性相同的格子数目
		s2[b[i]][i%2]=(s2[b[i]][i%2]+a[i])%mod;//记录b[i]颜色奇偶性相同的数字总和
	}
	for(int i=1;i<=n;i++){
		int y=b[i];
		ans+=i*(s2[y][i%2]+a[i]*(s1[y][i%2]-2)%mod)%mod;
		ans%=mod;
	}
	cout<<ans;
	return 0;
}
```



## 单调栈



## 单调队列



## 课后习题

