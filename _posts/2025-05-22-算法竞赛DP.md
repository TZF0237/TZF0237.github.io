---
layout: post
title: 算法竞赛DP
date: 2025-05-22
tags:
- ACM-ICPC
categories: ACM-ICPC
description: 描述
---

# 《算法竞赛》第 5 章 动态规划


<!-- more -->

## 1. DP概念和编程方法

### 1.1 DP的概念

DP是求解多阶段决策问题最优化的一种算法思想。

解决的问题具有两个特征。

**重叠子问题**：子问题会重叠，即多个不同问题会用到相同子问题

**最优子结构**：大问题的最优解由小问题最优解得来，但小问题最优解求解过程与大问题无关。

### 1.2 DP的两种编程方法

自顶向下（先大问题，再小问题），即递归记忆化搜索。

自底向上（先小问题，再大问题），即递推。

自底向上的优点是编码更直接。

### 1.3 DP的设计和实现

刷题。

### 1.4 滚动数组

滚动数组可以减少空间复杂度，但也会损失DP数组存储的信息。

如 01 背包使用滚动数组优化后，无法输出具体方案。

有的DP状态已经是最小空间复杂度，无法再使用滚动数组优化。

两种实现滚动数组的方式。

**交替滚动**：用 $$dp[0][]$$ 和 $$dp[1][]$$ 交替滚动

例如01背包

```c++
int now=0,old=1;
for(int i=1;i<=n;i++){
    swap(now,old);//交替滚动
    for(int j=0;j<=c;j++){
        if(v[i]>j) dp[now][j]=dp[old][j];
        else dp[now][j]=max(dp[old][j],dp[old][j-v[i]]+w[i]);
    }
}
```

**自我滚动**：自我覆盖

例如01背包

```c++
for(int i=1;i<=n;i++){
    for(int j=c;j>=v[i];j--){
        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
}
```

## 2. 线性DP

一些经典线性DP问题。

#### 1. 分组背包

有一些物品，分为 n 组，第 i 组第 k 个物品体积为 $$c[i][k]$$，价值为 $$w[i][k]$$。每组最多选一个，给定容量为 C 的背包，如何选使总价值最大。

[P1757 通天之分组背包 - 洛谷](https://www.luogu.com.cn/problem/P1757)

状态：$$dp[i][j]$$，前 i 组物品装容量 j 的背包获得最大价值。

状态转移方程：$$dp[i][j]=max(dp[i-1][j],dp[i-1][j-c[i][k]]+w[i][k])$$

对于 $$dp[i][j]$$ 只使用到 $$dp[i-1][]$$，所以可使用滚动数组优化。

即状态转移方程：$$dp[j]=max(dp[j],dp[j-c[i][k]]+w[i][k])$$

```c++
for(int i=1;i<=zu;i++)//组数
    for(int j=m;j>=0;j--)//体积
        for(int k=1;k<=a[i];k++)//第i组物品数
            if(j>=v[i][k])
                dp[j]=max(dp[j],dp[j-v[i][k]]+w[i][k]);
```

#### 2. 多重背包

给定 n 种物品和一个背包，第 i 种物品的体积为 $$c_i$$，价值为 $$w_i$$，并且有 $$m_i$$ 个，背包总容量为 C。使背包总价值最大。

[P1776 宝物筛选 - 洛谷](https://www.luogu.com.cn/problem/P1776)

4 种解法。

第一种，转换为01背包，把每种的背包都看作单独物品。

时间复杂度为$$O(C\sum _{i=1}^n m_i)$$。

```c++
cin>>n>>C;
for(int i=1;i<=n;i++){
    int a,b,c;cin>>a>>b>>c;
    while(c--) w.push_back(a),v.push_back(b);
}
for(int i=0;i<w.size();i++){
    for(int j=C;j>=v[i];j--){
        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
}
cout<<dp[C]<<"\n";
```

第二种，转换为分组背包，时间复杂度也为$$O(C\sum _{i=1}^n m_i)$$。

```c++
cin>>n>>C;
for(int i=1;i<=n;i++) cin>>w[i]>>c[i]>>m[i];
for(int i=1;i<=n;i++){
    for(int j=C;j>=0;j--){
        for(int k=1;k<=m[i];k++){
            if(k*c[i]>j) break;
            dp[j]=max(dp[j],dp[j-k*c[i]]+k*w[i]);
        }
    }
}
cout<<dp[C];
```

第三种，二进制拆分优化

若第 i 种物品有 m 个，放进背包的方案有 m+1 种，组合出这 m+1 种并不需要m个物品。根据二进制的原理，任何一个十进制数 X 都可以使用 2 的不同幂次方相加得到，这些幂次方个数只有 $$log_2 X$$ 个。所以第 i 种物品的 m 个物品，可以使用 $$log_2 m$$ 个表示。复杂度从 $$O(C \sum_{i=1}^n m_i)$$ 优化到 $$O(C \sum_{i=1}^n log_2 ~ m_i)$$ 。

注意拆分的具体实现，不能全部拆成 2 的倍数，而是先按 2 的幂次方从小到大拆，最后一个小于或等于最大倍数的余数。这样能保证拆出的数相加在 $$[1,m_i]$$ 范围内，不会大于 $$m_i$$ 。

例如，$$m_i=25$$，把它拆成 $$1+2+4+8+10$$，最后余数 10，可保证这拆分数组合不会超过 25。

```c++
int n,C,dp[N];
int w[N],c[N],m[N];
int new_n;//二进制拆分后的新物品总数量
int new_w[N],new_c[N],new_m[N];//二进制拆分后的新物品
void solve(){
	cin>>n>>C;
	for(int i=1;i<=n;i++) cin>>w[i]>>c[i]>>m[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m[i];j<<=1){//二进制枚举
			m[i]-=j;//减去已拆分的
			new_c[++new_n]=j*c[i];//新物品
			new_w[new_n]=j*w[i];
		}
		if(m[i]){
			new_c[++new_n]=m[i]*c[i];
			new_w[new_n]=m[i]*w[i];
		}
	}
	//下面是滚动数组的 01背包
	for(int i=1;i<=new_n;i++)
		for(int j=C;j>=new_c[i];j--)
			dp[j]=max(dp[j],dp[j-new_c[i]]+new_w[i]);
	cout<<dp[C]<<"\n";
}
```

二进制拆分可以看作多重背包问题的标准解法，下面是最优解法。

第四种，单调队列优化

原理后续DP优化再补。时间复杂度为 $$O(nC)$$ ，是最优的解法。

```c++
int n,C,dp[N],ans,tmp;
int f[N],que[N],num[N];
void solve(){
	cin>>n>>C;
	for(int i=1;i<=n;i++){
		int v,w,m;
		cin>>w>>v>>m;
		if(v==0){ans+=m*w;continue;}//体积为0，避免除数为0的情况
		int can_use=min(m,C/v);//can_use表示最大可用数量
		for(int j=0;j<v;j++){//枚举每一个余数
			//注意这要保证转移到所有可以转移点
			int all=(C-j)/v,head=1,tail=0;//找到区间内这个余数下有机会转移到的所有点
			//每次重置队列
			for(int k=0;k<=all;k++){//转移数量从0到all不等
				int push_in=f[j+k*v]-k*w;
				while(head<=tail&&push_in>=que[tail]) tail--;//维护队列取最大
				tail++;
				que[tail]=push_in;
				num[tail]=k;
				while(head<=tail&&num[head]+can_use<k) head++;//无法实现转移的话
				f[j+k*v]=max(f[j+k*v],que[head]+k*w);
				tmp=max(tmp,f[j+k*v]);
			}
		}
	}
	cout<<tmp+ans<<"\n";
}
```

#### 3. 最长公共子序列（LCS）

给定两个序列 X 和 Y ，找出 X 和 Y 的一个最长公共子序列。

状态：$$dp[i][j]=序列X在第i位置序列Y在第j位置的最长公共子序列$$

状态转移方程：
$$
dp[i][j]=dp[i-1][j-1]+1,~~X[i]==Y[i];\\
dp[i][j]=max(dp[i-1][j],dp[i][j-1]),~X[i]!=Y[j];
$$
时空复杂度都为 $$O(n^2)$$。

[P1439 最长公共子序列 - 洛谷](https://www.luogu.com.cn/problem/P1439)

P1439这题序列长度为1e5，正常复杂度过不了，但是多了排列的限制条件，就可以将此题转化为LIS。

```c++
int a[N],b[N];
void solve(){
	int n,len=0;cin>>n;
	map<int,int> mp;
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		mp[x]=i;
	}
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		a[i]=mp[x];
	}
	for(int i=1;i<=n;i++){
		if(b[len]<=a[i]) b[++len]=a[i];
		else{
			int x=upper_bound(b+1,b+len+1,a[i])-b;
			b[x]=a[i];
		}
	}
	cout<<len<<"\n";
}
```

[Problem - 1159](https://acm.hdu.edu.cn/showproblem.php?pid=1159)

基础的LCS

```c++
int dp[N][N];
void solve(){
	string s1,s2;cin>>s1>>s2;
	int n=s1.size(),m=s2.size();
	s1=" "+s1,s2=" "+s2;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;
			else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
		}
	}
	cout<<dp[n][m]<<"\n";
}
```

#### 4. 最长递增子序列（LIS）

给定一个长度为 n 的数组，找出一个最长的单调递增子序列。

状态：$$dp[i]$$ 在以第 $$i$$ 个数为结尾的最长上升子序列的最大长度

转移方程：$$dp[i]=max(dp[j]+1),0<j<i,A_j<A_i$$

DP不是LIS问题的最优解，使用树状数组或者贪心二分复杂度更低。

使用DP求解是 $$O(n^2)$$ 的，采用树状数组或者贪心+二分是 $$Olog_2n$$ 的。

[B3637 最长上升子序列 - 洛谷](https://www.luogu.com.cn/problem/B3637)

```C++
int dp[N],a[N];//DP
void solve(){
	int n,ans=0;cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		dp[i]=1;
		for(int j=1;j<i;j++)
			if(a[i]>a[j]) dp[i]=max(dp[i],dp[j]+1);
		ans=max(ans,dp[i]);
	}
	cout<<ans<<"\n";
}
```

```c++
int a[N],b[N];//贪心+二分
void solve(){
	int n,len=0;cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	b[++len]=a[1];
	for(int i=2;i<=n;i++){
		if(a[i]>b[len]) b[++len]=a[i];
		else{
			int x=lower_bound(b+1,b+len+1,a[i])-b;
			b[x]=a[i];
		}
	}
	cout<<len<<"\n";
}
```

[Problem - 1257](https://acm.hdu.edu.cn/showproblem.php?pid=1257)

上面这题也是一道LIS的模板。

#### 5. 编辑距离

给定两个单词，计算将第一个单词转换为第二个单词所需的最小操作数。单词允许插入一个字符、删除一个字符、替换一个字符。

状态：$$dp[i][j]$$ 表示从 s1 的前 $$i$$ 个字符转换到 s2 的前 $$j$$ 个字符所需最小操作数。

如果 $$s1[i]==s2[j]$$ ，则 $$dp[i][j]=dp[i-1][j-1]$$，因为不需要操作。

如果不等，有三种情况

- 删除 s1 的最后字符（相当于 s1 最后插入），$$dp[i-1][j]+1$$
- 在 s2 插入 s1 的最后字符（相当于 s2 最后删除），$$dp[i][j-1]+1$$
- 将某个单词最后字符替换，$$dp[i-1][j-1]+1$$

即如果 $$s1[i]!=s2[j]$$，则 $$dp[i][j]=min{dp[i-1][j-1],dp[i-1][j],dp[i][j-1]}+1$$

注意初始化，需要将 $$dp[i][0]和dp[0][i]$$ 赋值为 $$i$$，因为某串无字符时，需要删加长度字符。

算法复杂度为 $$O(mn)$$。

[P2758 编辑距离 - 洛谷](https://www.luogu.com.cn/problem/P2758)

```c++
int dp[N][N];
void solve(){
	string s1,s2;cin>>s1>>s2;
	int n=s1.size(),m=s2.size();
	s1=" "+s1,s2=" "+s2;
	for(int i=0;i<=n;i++) dp[i][0]=i;
	for(int i=0;i<=m;i++) dp[0][i]=i;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1];
			else dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
		}
	}
	cout<<dp[n][m];
}
```

#### 6. 最小划分

给出一个正整数数组，把它分成 $$S_1$$ 和 $$S_2$$ 两部分，使 $$S_1$$ 的数字和与 $$S_2$$ 的数字和的差绝对值最小。

转化为求最大容量为 $$sum/2$$ 的背包问题。

[724 · 最小划分 - LintCode](https://www.lintcode.com/problem/724/)

[P3010 Dividing the Gold S - 洛谷](https://www.luogu.com.cn/problem/P3010)

这题不仅需要求最小差，还需要求方案数量。

可以使状态 $$dp[i]$$ 为总和为 $$i$$ 的方案数。

初始化为 $$dp[0]=1$$，转移方程为 $$dp[i]+=dp[i-a[i]]$$。

但是需要从后往前求出最接近 $$sum/2$$ 的值，但是取模可能会破坏。

所以我们使用一个变量存储。

```c++
int a[N],ans,dp[N];
void solve(){
	int n,sum=0;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];sum+=a[i];
	}
	dp[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=sum/2;j>=a[i];j--){
			dp[j]+=dp[j-a[i]];
			if(dp[j]) ans=max(ans,j);
			dp[j]%=mod;
		}
	}
	cout<<sum-ans*2<<"\n"<<dp[ans]%mod;
}
```

#### 7. 行走问题

给定一个整数 $$n$$ ，表示距离的步骤，一个人每次能走 $$1\sim 3$$ 步，问走到 $$n$$ 的方案数。

状态：$$dp[i]$$ 为走到 $$i$$ 的方案数
转移方程：$$dp[i]=dp[i-1]+dp[i-2]+dp[i-3],i>2$$，初始化需判断大小

我觉得可以归结于计数类DP。

#### 8. 矩阵最长递增路径

给定一个矩阵，找最长一条路径，要求路径上的数字递增。矩阵的每个点可以向四个方向移动。

第一种方法，记忆化搜索。

第二种方法，DP。

为了满足DP的无后效性，我们需要先从低的点算起，后面高的点对低的没有影响。

从低的点算起可以使用优先队列。

状态：$$dp[i][j]$$ 表示以坐标 $$(i,j)$$ 为终点的最长路径长度

转移方程：$$dp[i][j]=max(dp[i-1][j],dp[i+1][j],dp[i][j-1],dp[i][j+1])+1,a[i][j]>a[next][next]$$

```c++
struct nod{
	int i,j,num;
	friend bool operator < (nod a,nod b){
		return a.num>b.num;
	}
};
priority_queue<nod> q;
int bu[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
int n,m,dp[N][N],a[N][N],ans;
void solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			dp[i][j]=1;
			cin>>a[i][j];
			nod x;x.i=i,x.j=j,x.num=a[i][j];
			q.push(x);
		}
	}
	while(!q.empty()){
		nod x=q.top();q.pop();
		int i=x.i,j=x.j,num=x.num;
		for(int k=0;k<4;k++){
			int xx=bu[k][0],yy=bu[k][1];
			if(a[i+xx][j+yy]<num) dp[i][j]=max(dp[i][j],dp[i+xx][j+yy]+1);
		}
		ans=max(ans,dp[i][j]);
	}
	cout<<ans;
}
```



#### 9. 子集和问题



#### 10. 最优游戏策略



#### 11. 矩阵链乘法



#### 12. 布尔括号问题



#### 13. 最短公共超序列

 

## 3. 数位统计DP

### 3.1 数位DP的递推实现

### 3.2 数位DP的记忆化搜索实现

### 3.3 数位DP例题

## 4. 状态压缩DP

### 4.1 Hamilton问题

### 4.2 状压DP原理

### 4.3 状压DP例题

### 4.4 三进制状压DP

## 5. 区间DP

### 5.1 石子合并问题

### 5.2 模板代码

### 5.3 区间DP例题

### 5.4 二维区间DP

## 6. 树形DP

### 6.1 树形DP基本操作

### 6.2 背包与树形DP

## 7. 一般优化

## 8. 单调队列优化

### 8.1 单调队列优化原理

### 8.2 单调队列优化例题

## 9. 斜率优化/凸壳优化

### 9.1 状态转移方程变换平面斜率问题

### 9.2 求一个DP\[ i \]

### 9.3 求所有DP\[ i \]

### 9.4 例题

## 10. 四边形不等式优化

### 10.1 应用场合

### 10.2 四边形不等式优化操作

### 10.3 四边形不等式定义和单调性定义

### 10.4 四边形不等式定理

### 10.5 例题



