---
layout: post
title: 标题
date: 2025-05-03
tags:
- 标签
categories: 分类
description: 描述
---

# 动态规划学习（1）

《算法竞赛入门到进阶》学习。

<!-- more -->

## 《算法竞赛入门到进阶》

### 1. 动态规划的概念和思想

DP（Dynamic Programming）是一种算法思想，不是一个特定的算法。

DP与分治法的区别：

- 分治法是将问题分成独立的子问题，每个子问题能独立解决
- DP的子问题是相关的，前面子问题的解决结果被后面的子问题使用。

求解DP有 $3$ 步，定义状态、状态转移、算法实现。

### 2. 基础DP

基础DP是一些经典问题，如递推、01背包、最长公共子序列（LCS）、最长递增子序列（LIS）等。

#### 2.1 硬币问题

##### 2.1.1 最少硬币问题

有 n 种硬币，面值分别为 $v_1,v_2,...,v_n$，数量无限。输入非负整数 s，选硬币使其和为 s。要求输出最少硬币组合。

```c++
void solve(){
	int S=251,N=5,s;
	int Min[S],v[5]={1,5,10,25,50};
	memset(Min,0x3f,sizeof(Min));
	Min[0]=0;
	for(int j=0;j<N;j++)
		for(int i=v[j];i<S;i++)
			Min[i]=min(Min[i],Min[i-v[j]]+1);
	cin>>s;
	cout<<Min[s]<<"\n";
}
```

上述时间复杂度是 $O(SN)$。

##### 2.1.2 打印最少硬币组合

在DP中，除求最优解的数量外，往往还要求输出最优解本身。

在最少硬币问题中，如果要求打印组合方案，需要增加一个记录表 Min_path[i]，记录金额 i 需要的最后一个硬币。利用 Min_path\[\] 逐步倒推，就能得到所有的硬币。

```c++
void prin(int *Min_path,int s){
	while(s){
		cout<<Min_path[s]<<" ";
		s=s-Min_path[s];
	}
}
void solve(){
	int S=251,N=5,s;
	int Min[S],v[5]={1,5,10,25,50};
	int Min_path[S]={0};
	memset(Min,0x3f,sizeof(Min));
	Min[0]=0;
	for(int j=0;j<N;j++)
		for(int i=v[j];i<S;i++){
			if(Min[i]>Min[i-v[j]]+1){
				Min_path[i]=v[i];
				Min[i]=min(Min[i],Min[i-v[j]]+1);
			}
		}
	cin>>s;
	prin(Min_path,s);
}
```

用数组存储由哪个状态转移而来，即可得到转移路径。

##### 2.1.3 所有硬币组合

有 n 种硬币，面值分别为 $v_1,v_2,...,v_n$，数量无限。输入非负整数 s，选硬币使其和为 s。要求输出所有的硬币组合数量。

如果选取硬币的数量无限：

```c++
void solve(){
	int S=251,N=5,s;
	int dp[S]={0},v[5]={1,5,10,25,50};
	dp[0]=1;
	for(int i=0;i<N;i++)
		for(int j=v[i];j<S;j++)
			dp[j]=dp[j]+dp[j-v[i]];
	cin>>s;
	cout<<dp[s]<<"\n";
}
```

如果选取的硬币数量有限：

```c++
void solve(){
	int C=101,M=251;
	int dp[M][C]={0};
	int v[5]={1,5,10,25,50};
	int ans[M]={0};
	dp[0][0]=1;
	for(int i=0;i<5;i++)
		for(int j=1;j<C;j++)
			for(int k=v[i];k<M;k++)
				dp[k][j]+=dp[k-v[i]][j-1];
	for(int i=0;i<M;i++)
		for(int j=0;j<C;j++)
			ans[i]+=dp[i][j];
	int s;
	while(cin>>s)
		cout<<ans[s]<<"\n";
}
```

#### 2.2 01背包问题

约束条件：
$$
\sum_{i=1}^{n} w_ix_i≤C ~,~ x_i∈\{0,1\},1≤i≤n
$$
目标函数：
$$
max\sum_{i=1}^{n}v_ix_i
$$
基础代码如下：

```c++
void solve(){
	int n,m;
	cin>>n>>m;
	int w[n],v[n],dp[n][m+1]={0};
	for(int i=0;i<n;i++) cin>>w[i];
	for(int i=0;i<n;i++) cin>>v[i];
	for(int i=0;i<n;i++){
		for(int j=0;j<=m;j++){
			if(j<v[i]) dp[i][j]=dp[i-1][j];
			else dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
		}
	}
	cout<<dp[n][m]<<"\n";
}
```

滚动数组覆盖了中间转移状态，只留下了最后的状态，所有损失了很多信息，导致无法输出背包的方案。

滚动数组优化：

```c++
void solve(){
	int n,m;
	cin>>n>>m;
	int w[n],v[n],dp[m+1]={0};
	for(int i=0;i<n;i++) cin>>w[i];
	for(int i=0;i<n;i++) cin>>v[i];
	for(int i=0;i<n;i++){
		for(int j=m;j>=v[i];j--){
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
		}
	}
	cout<<dp[m]<<"\n";
}
```

#### 2.3 最长公共子序列（LCS）

最长公共子序列（Longest Common Subsequence）问题：给定两个序列 X 和 Y，找出 X 和 Y 的一个最长公共子序列。

用 $dp[i][j]$ 表示子序列 $$X_i$$ 和 $$Y_j$$ 的最长公共子序列长度。

当 $X_i=Y_i$ 时，找出 $$X_{i-1}$$ 和 $$Y_{i-1}$$ 的最长公共子序列，然后在其尾部加上 $X_i$ 即可得到 $$X$$ 和 $$Y$$ 的最长公共子序列。

当 $$X_i≠Y_i$$ 时，最长公共子序列就是 $$[X_{i-1},Y_j]$$ 的LCS和 $$[X_i,Y_{j-1}]$$ 的LCS二者中最大值。

```c++
void solve(){
	string s1,s2;
	cin>>s1>>s2;
	int dp[s1.size()+1][s2.size()+1]={0};
	for(int i=1;i<=s1.size();i++)
		for(int j=1;j<=s2.size();j++){
			if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
			else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
		}
	cout<<dp[s1.size()][s2.size()]<<"\n";
	return ;
}
```

滚动数组优化：

```c++
void solve(){
	string s1,s2;
	cin>>s1>>s2;
	int dp[2][s2.size()+1];
	memset(dp,0,sizeof(dp));
	for(int i=1;i<=s1.size();i++)
		for(int j=1;j<=s2.size();j++){
			if(s1[i-1]==s2[j-1]) dp[i%2][j]=dp[(i-1)%2][j-1]+1;
			else dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
		}
	cout<<dp[s1.size()%2][s2.size()]<<"\n";
	return ;
}
```

这里不能定义 $$int~dp[2][s2.size()+1]=\{0\}$$ ，这样dp数组为变长数组（VLA），VLA是C99特性，不是标准C++的一部分，某些编译器（如GCC扩展）可能无法正确初始化。

#### 2.4 最长递增子序列（LIS）

最长递增子序列（Longest Increasing Subsequence）。

第一种方法，将序列排序后与原序列求最长公共子序列即为LIS，复杂度为 $$O(N^2)$$。

```c++
void solve(){
	int n;cin>>n;
	int a[n],b[n],dp[2][n+1];
	for(int i=0;i<n;i++) cin>>a[i],b[i]=a[i];
	sort(b,b+n);
	memset(dp,0,sizeof(dp));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(a[i-1]==b[j-1]) dp[i%2][j]=dp[(i-1)%2][j-1]+1;
			else dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
		}
	cout<<dp[n%2][n]<<"\n";
}
```

第二种方法，直接DP求解，状态 $$dp[i]$$ 表示以第 $$i$$ 个数为结尾的LIS长度，状态转移方程为 $$dp[i]=max\{0,dp[j]\}+1,~0<j<i,A_j<A_i$$ ，

答案为 $$max\{dp[i]\}$$，复杂度为 $$O(N^2)$$ 。

```c++
void solve(){
	int n,ans=0;cin>>n;
	int a[n],dp[n+1];
	for(int i=0;i<n;i++) cin>>a[i];
	memset(dp,0,sizeof(dp));
	for(int i=0;i<n;i++){
		dp[i]=1;
		for(int j=0;j<i;j++)
			if(a[j]<a[i]) dp[i]=max(dp[i],dp[j]+1);
	}
	for(int i=0;i<n;i++) ans=max(ans,dp[i]);
	cout<<ans<<"\n";
}
```

第三种方法，单调队列，复杂度为 $$O(nlogn)$$。

```c++
void solve(){
	int n,ans=0;cin>>n;
	int a[n];
	for(int i=0;i<n;i++) cin>>a[i];
	vector<int> v;
	v.push_back(a[0]);
	for(int i=1;i<n;i++){
		int x=upper_bound(v.begin(),v.end(),a[i])-v.begin();
		if(x==v.size()) v.push_back(a[i]);
		else v[x]=a[i];
	}
	cout<<v.size()<<"\n";
}
```

### 3. 递推与记忆化搜索

记忆化搜索，在用递归实现DP时，在递归程序中记录计算过的状态，并在后续的计算中跳过已经算过的重复状态。

在很多情况下，记忆化搜索的逻辑思路和程序比直接写递推更简单。

### 4.区间DP

区间DP的主要思想是现在小区间进行DP得到最优解，再利用小区间的最优解合并求大区间的最优解。

区间DP的两个难点，枚举所有可能的区间、状态转移方程。

下面用两个经典问题讲解：

**1.石子合并**

设有 $N$堆石子排成一排，其编号为 $1,2,3,\cdots,N$。每堆石子有一定的质量 $m_i$。现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。输出最小代价。

状态：$$DP[i][j]$$ 为从第 $$i$$ 堆石子到第 $$j$$ 堆石子的最小花费。

转移方程：$$dp[i][j]=min(dp[i][k]+dp[k+1][j])+sum[i][j],i≤k≤j$$

```c++
void solve(){
	int n;cin>>n;
	int m[n],dp[n][n],sum[n];
	sum[0]=0;
	memset(dp,0,sizeof(dp));
	for(int i=0;i<n;i++) 
		cin>>m[i],sum[i]=sum[i-1]+m[i];
	for(int len=1;len<n;len++){
		for(int i=0;i+len<n;i++){
			int j=i+len;
			dp[i][j]=0x3f3f3f3f;
			for(int k=i;k<j;k++){
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);
			}
		}
	}
	cout<<dp[0][n-1]<<"\n";
}
```

时间复杂度为 $$O(N^3)$$，只能用来处理规模 $$n<250$$ 的问题。